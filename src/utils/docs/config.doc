# DynamicConfig: ğŸ§° A robust and elegant configuration class for managing OpenAI-related settings.
# Utilizes Pydantic for validation, ensuring type correctness and mandatory field presence. ğŸ›¡ï¸

# Singleton pattern: ğŸ•’ Ensures that only one instance of DynamicConfig is created.
# This pattern prevents multiple configurations from being loaded, maintaining consistency. ğŸš«

# ClassVar: ğŸ“ Used for defining class-level variables that are not Pydantic fields. ğŸ—ï¸

# BaseModel fields: ğŸ“Š Defined with types and default values.
# Required fields (like 'api_key') are explicitly stated, ensuring they are provided in the TOML file. ğŸ”‘

# logger method: ğŸ“¢ Provides a consistent logging interface across the application.
# Utilizes Python's standard logging library for versatile logging management. ğŸ“œ

# __init__: ğŸš€ Custom initializer to enforce the singleton pattern.
# Raises an exception if an instance already exists, safeguarding against multiple instantiations. ğŸš·

# get_instance: ğŸ” A class method to retrieve the singleton instance.
# Ensures that DynamicConfig is properly initialized before being accessed. ğŸ‘€

# load_from_toml: ğŸ“‚ Class method to load configuration from a TOML file.
# Handles file loading errors gracefully and validates the content before creating an instance. ğŸŒ

# Error handling: ğŸš§ Utilizes try-except blocks to gracefully handle and log potential errors.
# Differentiates between file not found, TOML parsing errors, and other unexpected exceptions. âš ï¸

# validate_toml: ğŸ§ A class method for additional validation of TOML data.
# Checks for required fields, verifies data types, and confirms the existence of specified paths. ğŸ“‹

# logging.basicConfig: ğŸŒŸ Sets up global logging configuration.
# Ensures consistent logging format and level across the entire application. ğŸ“ˆ

# Main execution block: ğŸš€ Tries to load and initialize the DynamicConfig.
# On failure, logs an error and exits gracefully, preventing further execution with invalid configuration. âŒ
